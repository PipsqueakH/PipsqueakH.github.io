---
layout: post
title: "Monad学习笔记（0）"
description: ""
category: 
tagline: "引言"
tags: []
---
{% include JB/setup %}

“A monad is just a monoid in the category of endofunctors。”
--Philip Wadler

Philip Wadler的名言恐怕是所有关于Monad的教程中最著名的一句话，
在解释何为Monad的一句话中用了三个概念 -- “monoid”、“category”、“endofuntor”，
即便是最有耐心的读者看到这里大概也会失去信心，因为函数式编程中最重要或许也是最基本的概念“Monad”，
是从范畴论中借鉴来的，这使得大多数不具备数学背景（更准确的说法应该是代数背景）的程序员在理解Monad的过程中都会遇到巨大的挑战。无怪乎有人说“每一个理解了Monad的程序员都是体验了一场精神之旅”，
这一系列的笔记正是笔者在理解Monad的过程中写下的。

鉴于笔者个人的兴趣和口味，Monad本身是从范畴论中引入到函数式编程中的，因此理解Monad也要从理解范畴论中的monad开始，然后可以自然的引入函数式编程中的概念。[hongjiang的博客](http://hongjiang.info/tag/monad/)提供了很好的参考，
只可惜写到endofunctor的部分之后就改变了思路，完全跳开了理论的部分（也是范畴论中十分精彩的地方），
直接进入到Monad的应用，还没有把故事的来龙去脉讲清楚。因此，本系列笔记的写作思路是先给出范畴论中基本概念的描述，
在建立了抽象的定义之后，再给出Haskell中所对应的具体对象，力图从理论上把monad的概念解释清楚。
*用首字母是否大写来区别两种概念*，例如“Monad”是指Haskell中概念，而“monad”是范畴论中的概念。
基于这种思路，本系列笔记的对象读者包括了对monad的理论基础有兴趣的程序员和对范畴论的具体应用有兴趣的数学家。
如果你更有兴趣知道monad是如何使用的，也许Wadler的论文[《Monads for functional programming》](http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf)会更有价值。

作为该系列笔记的第0篇，本文只讨论总体的框架（并不严格），具体的细节会在后续文章中展开。
还是从开篇的“A monad is just a monoid in the category of endofunctors。” 谈起，
这句话翻译成中文大约是这样：一个模就是一个自函子范畴上的一个独异点。

>     这里有两处需要说明。首先，在大多数中文的Monad介绍中，monad都是被翻译成“单子”的,事实上，“单子”一词来源于莱布尼茨的单子论（Monadology），用在范畴论中不免有些牵强。“模”这个翻译来自于贺伟《范畴论》（貌似这也是国内第一部范畴论的书籍）。第二，monoid通常被翻译成“幺半群”，少数资料中被翻译成“独异点”，其概念来源于抽象代数。诚然，Haskell中的Monoid从概念上来说就是抽象代数中的幺半群，但是范畴论的monoid已经是抽象代数中的幺半群的推广，因此，如果拿幺半群的概念放在范畴论中来理解monad，只会引起歧义而已。在这一系列的笔记中，“幺半群”指代抽象代数中的“monoid”，
而“独异点”指代范畴论中的“monoid”。另外也特别提醒读者，
Haskell的类型类“Monoid”和我们在讨论monad时说的“a monoid in the category of endofunctors”中的“monoid”并不是一回事。

那么，什么是范畴(category)呢？蛋疼的代数学家们喜欢研究一些特定的对象和这些特定对象之间的映射关系，
比如集合与集合之间的映射。那么把具有相同性质的对象和他们所对应的映射再进行抽象就是范畴，
一个范畴中可以有很多个对象，而两个对象之间的映射关系被称为“态射(morphism)”。
具体在Haskell中，一个类型（比如Int）就是一个对象，两个类型之间的函数（比如Int -> Double）就是一个态射。
现在，对象和态射被组合到了一起，做成了一个范畴，那么对一个范畴，有什么可以研究的呢？
很自然的，既然对象之间可以有映射，那么范畴之间也可以定义映射才对，范畴之上定义的映射就是函子(functor)，
显然，函子在对范畴做映射的时候其实是干了两件事：1. 把A范畴中的对象映射到B范畴中的对象；
2. 把A范畴中的态射映射到了B范畴中的态射。具体在Haskell中，这就是函子(Functor)的作用。
首先一个函子F可以把一个类型映射成一个新类型(F a)， 其次，每个函子都定义了一个像这样的fmap：

`
fmap :: ( a -> b ) -> ( F a -> F b )
`

把一个函数(a -> b) 映射成了另一个函数 ( F a -> F b).

再前(dan)进(teng)一点，既然范畴之间能定义叫做函子的映射，那函子之间也能定义映射。
两个函子之间的映射究竟映射了什么在此先不深究，姑且把这种东西称为“自然变换(natural transformation)”。
现在，把函子本身看做是一种对象，而这种对象之间又存在一个叫做“自然变换”的映射，
两者合起来就是一种特殊的范畴--函子范畴(catogory of functors)。
如果是在自函子(endofunctor)和其对应的自然变换上定义的范畴就是自函子范畴(category of endofunctors)。
其中，自函子就是把C范畴映射到自己的函子（当然，这样的函子可以把A对象映射到B对象，也可以把f态射映射到g态射，
只要B对象和f态射也属于C范畴就可以了）。

对于普通的函数(我是说数学中的f(x)=x+1这种，不是编程里的函数。。。)，可以定义有两个变元的二元函数f(x, y)；
那么我们也可以定义双函子(bifunctor)F(C, D)，只不过是把C, D两个范畴做成乘积（也就是把两个范畴里的对象和态射分别做了笛卡尔积得到了一个新的范畴），
再映射到另一个范畴而已。这时，如果一个双函子有这种形式：(C, C) -> C，也就是说把C范畴和自己的乘积范畴映射到了自己，
那就把这种形式的函子称作是一个张量积(tensor product)。如果这个张量积能满足某些一致性条件(coherence conditions),
C这个范畴就被称作“monoidal category”。如果一个函子是两个monoidal category之间映射，
这个函子就被称为“monoidal functor”。在Haskell中，Applicative Functor就是一个monoidal functor，
如果读者熟悉Applicative Functor，也许会觉得这不可思议，
但是如果用另一种形式来定义Applicative Functor，他们之间的联系会变得显而易见。

由前所述，模(monad)是一个独异点(monoid)，而独异点是幺半群的推广。

>     在一个集合中，如果任意两个元素之间可以定义一种称为“乘法”(有时也被称为“加法”)的运算,
这种运算是符合结合律的，那么这个集合和其上的乘法就是一个半群(semi-group)。例如整数集和通常意义下的加法。
如果这个这个半群中有一个可以被称为“单位元(幺元)”的元素，这就是一个幺半群。
所谓单位元就是和任意元A做乘法之后还是得到A的那个元素，比如加法半群上的“0”。

独异点的严格定义放在后面的章节叙述，在此只从直觉上介绍一个自函子范畴上的半群构造应该是什么样的。
F是一个函子，FF（表示两个函子的复合，如果难以理解就想一想两个函数是怎么复合的）也是一个函子，
定义一个FF到F的自然变换$\mu$，如果把函子F本身看作是一个集合（尽管它并不是）, 那么$\mu$可以被认为是这个集合上的二元运算，如果它满足结合律，那么F本身就类似于一个半群。
如果再在这个“半群”上找一个单位元，就成了一个幺半群。
可见，一个独异点其实是一个自函子范畴中的一个具有幺半群构造的函子，这就被称作模(monad)，
在Haskell中，一个Monad其实也就是一个Functor，而Monad Law保证了它具有类似乘法和单位元的性质。

到这里，“A monad is just a monoid in the category of endofunctors。”算是有了一个直观的解释。
后面的章节都是对上述内容的细节的补充。笔者力图能在尽可能做到严谨的同时又不落于迂腐。
希望能通过这一系列的文章，将把Haskell中和Monad相关的内容与范畴论中相应的概念对应起来，做到知其然，知其所依然。
理解这些概念需要费一些功夫，如果能为读者带来相应的乐趣，自然也是极好的。
